name: '[CI] Integration test / kubetest2'
inputs:
  k8s_version:
    required: true
    type: string
  arch:
    required: true
    type: string
  instance_type:
    required: true
    type: string
  resource_id:
    required: true
    type: string
  aws_region:
    required: true
    type: string
  log_bucket:
    required: true
    type: string
  image:
    description: 'NMA container image to deploy'
    required: true
  ami_type:
    description: 'AMI type (standard or nvidia)'
    required: false
    default: 'standard'
  test_filter:
    description: 'Test filter pattern (e.g., Test/DaemonSetReady)'
    required: false
    default: ''
runs:
  using: "composite"
  steps:
    - name: Setup Go
      uses: actions/setup-go@v5
      with:
        go-version: stable
        cache-dependency-path: go.sum

    - id: resolve-ami
      shell: bash
      run: |
        # Map arch input to SSM path format
        SSM_ARCH="x86_64"
        if [ "${{ inputs.arch }}" = "arm64" ]; then
          SSM_ARCH="arm64"
        fi
        echo "ssm_arch=${SSM_ARCH}" >> $GITHUB_OUTPUT
        
        # Resolve AMI from SSM Parameter Store
        AMI_ID=$(aws ssm get-parameter \
          --name /aws/service/eks/optimized-ami/${{ inputs.k8s_version }}/amazon-linux-2023/${SSM_ARCH}/${{ inputs.ami_type }}/recommended/image_id \
          --region ${{ inputs.aws_region }} \
          --query "Parameter.Value" \
          --output text)
        echo "ami_id=${AMI_ID}" >> $GITHUB_OUTPUT

    - name: Generate e2e manifests
      shell: bash
      run: make update-e2e-manifests

    - name: Build e2e test binary
      shell: bash
      run: make build-e2e

    - name: Prepare e2e test script
      id: prepare-test
      shell: bash
      run: |
        # Store absolute path to e2e binary
        echo "e2e_binary=$(pwd)/bin/e2e.test" >> $GITHUB_OUTPUT

        # Create a test script that kubetest2 will execute
        # Values are embedded directly because kubetest2 exec tester
        # does not forward positional arguments to the test command.
        cat > /tmp/run-e2e-tests.sh << SCRIPT
        #!/bin/bash
        
        IMAGE="${{ inputs.image }}"
        TEST_FILTER="${{ inputs.test_filter }}"
        E2E_BINARY="$(pwd)/bin/e2e.test"
        
        echo "Running e2e tests with image: \${IMAGE}"
        echo "Test filter: \${TEST_FILTER:-<none>}"
        
        # Build test command
        TEST_CMD="\${E2E_BINARY} --test.v --test.timeout 30m --install=true --image=\${IMAGE}"
        
        # Add filter if provided
        if [ -n "\${TEST_FILTER}" ]; then
          TEST_CMD="\${TEST_CMD} --test.run '\${TEST_FILTER}'"
        fi
        
        echo "Executing: \${TEST_CMD}"
        eval \${TEST_CMD}
        SCRIPT
        chmod +x /tmp/run-e2e-tests.sh

    # TODO: restore kubetest2 invocation after verifying argument plumbing
    - id: kubetest2
      shell: bash
      run: |
        echo "=== DRY RUN: verifying argument plumbing ==="
        echo "image: ${{ inputs.image }}"
        echo "k8s_version: ${{ inputs.k8s_version }}"
        echo "arch: ${{ inputs.arch }}"
        echo "instance_type: ${{ inputs.instance_type }}"
        echo "resource_id: ${{ inputs.resource_id }}"
        echo "aws_region: ${{ inputs.aws_region }}"
        echo "log_bucket: ${{ inputs.log_bucket }}"
        echo "ami_id: ${{ steps.resolve-ami.outputs.ami_id }}"
        echo "ami_type: ${{ inputs.ami_type }}"
        echo "test_filter: ${{ inputs.test_filter }}"
        echo "e2e_binary: ${{ steps.prepare-test.outputs.e2e_binary }}"
        echo "=== test script contents ==="
        cat /tmp/run-e2e-tests.sh
        echo "=== end dry run ==="

        # Fail if image is empty so we catch the bug immediately
        if [ -z "${{ inputs.image }}" ]; then
          echo "::error::image input is EMPTY â€” build output did not propagate"
          exit 1
        fi
